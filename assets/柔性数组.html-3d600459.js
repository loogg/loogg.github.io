import{_ as l,r as e,o as p,c as o,a as s,b as n,d as c,e as t}from"./app-3ca712e6.js";const r={},i=s("h2",{id:"参考链接",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#参考链接","aria-hidden":"true"},"#"),n(" 参考链接")],-1),B={href:"https://blog.csdn.net/imxiangzi/article/details/90758437",target:"_blank",rel:"noopener noreferrer"},d=t(`<h2 id="实现机制" tabindex="-1"><a class="header-anchor" href="#实现机制" aria-hidden="true">#</a> 实现机制</h2><p>在结构体最后加 <code>char[0]</code> 或 <code>char[1]</code> 的用法是GNU C的扩展，在ISO/IEC 9899-1999里面，这么写是非法的。</p><p>这种用法在C99中叫做 柔性数组。柔性数组成员前面必须至少有一个其它类型成员。包含柔性数组成员的结构要用malloc进行动态内存分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>主要是为了方便管理内存缓冲区，如果你直接使用指针而不使用数组，那么，你在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，（而此时分配的内存已经与结构体的内存不连续了，所以要分别管理即申请和释放）而如果使用数组，那么只需要一次就可以全部分配出来，反过来，释放时也是一样，使用数组，一次释放，使用指针，得先释放结构体内的指针，再释放结构体。还不能颠倒次序。</p></div><p>其实就是 <strong>分配一段连续的的内存，减少内存的碎片化</strong>。</p><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现" aria-hidden="true">#</a> 代码实现</h2><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> Msg</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">    ...</span><span style="color:#7F848E;font-style:italic;">         // 其它成员</span></span>
<span class="line"><span style="color:#ABB2BF;">    ...</span><span style="color:#7F848E;font-style:italic;">         // 其它成员</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> nLen;</span><span style="color:#7F848E;font-style:italic;">   // 一般char data[0]的前面会加一个长度nLen表示data的大小</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">char</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">data</span><span style="color:#ABB2BF;">[</span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">];</span><span style="color:#7F848E;font-style:italic;">   // char[0]或char[1]必须放在最后</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们要知道的一点就是：<strong>char data[0] 这个数组是没有元素的，它的地址紧跟着nLen后的地址，如果分配的内存大于结构体的实际大小，那么大出来的那部分就是data的内容</strong>。</p><p>实际使用时，一般这样用</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> dataBytes </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">10</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">             // 此处指定data的数据大小</span></span>
<span class="line"><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> Msg </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">p </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> Msg </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">)</span><span style="color:#61AFEF;">malloc</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">sizeof</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">struct</span><span style="color:#E06C75;"> Msg</span><span style="color:#ABB2BF;">)</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">+</span><span style="color:#E06C75;"> dataBytes</span><span style="color:#ABB2BF;">);</span><span style="color:#7F848E;font-style:italic;">   // 动态分配</span></span>
<span class="line"><span style="color:#ABB2BF;">p</span><span style="color:#C678DD;">-&gt;</span><span style="color:#ABB2BF;">nLen       </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> dataBytes;</span><span style="color:#7F848E;font-style:italic;">      // 把长度赋值给nLen，以方便其它部分使用此结构体</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="c99-使用不完整类型实现柔性数组" tabindex="-1"><a class="header-anchor" href="#c99-使用不完整类型实现柔性数组" aria-hidden="true">#</a> C99 使用不完整类型实现柔性数组</h2><p>在C99 中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组(flexible array)成员(也叫伸缩性数组成员)，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。</p><p>柔性数组成员只作为一个符号地址存在，而且必须是结构体的最后一个成员，sizeof 返回的这种结构大小不包括柔性数组的内存。柔性数组成员不仅可以用于字符数组，还可以是元素为其它类型的数组。</p><p>包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</p><p>柔性数组的使用请看下面的例子：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">typedef</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> test</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> a;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">double</span><span style="color:#ABB2BF;"> b;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">char</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">c</span><span style="color:#ABB2BF;">[</span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有些编译器会报错无法编译可以改成：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">typedef</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> test</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> a;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">double</span><span style="color:#ABB2BF;"> b;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">char</span><span style="color:#ABB2BF;"> c</span><span style="color:#C678DD;">[]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>应当尽量使用标准形式，在非C99的场合，可以使用指针方法。</p><p>需要说明的是：C89不支持这种东西，C99把它作为一种特例加入了标准。</p><p>但是，C99所支持的是incomplete type，而不是zero array，形同int a[0];这种形式是非法的，C99 支持的形式是形同int a[];只不过有些编译器把int a[0];作为非标准扩展来支持，而且在C99 发布之前已经有了这种非标准扩展了，C99 发布之后，有些编译器把两者合而为一了。</p></div>`,19);function y(v,u){const a=e("ExternalLinkIcon");return p(),o("div",null,[i,s("p",null,[s("a",B,[n("C语言中的柔性数组 C语言结构体中char[0]和char[1]的用法"),c(a)])]),d])}const D=l(r,[["render",y],["__file","柔性数组.html.vue"]]);export{D as default};
