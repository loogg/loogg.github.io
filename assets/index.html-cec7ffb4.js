import{_ as o,r as l,o as i,c,a as e,b as s,d as n,e as t}from"./app-22e550bc.js";const r="/assets/ModbusProtocol-7900ee6e.jpg",d="/assets/SlaveCallback-1958640b.jpg",p="/assets/zanshang-e2e5224e.jpg",u={},_=t('<h1 id="agile-modbus" tabindex="-1"><a class="header-anchor" href="#agile-modbus" aria-hidden="true">#</a> Agile Modbus</h1><h2 id="_1-introduction" tabindex="-1"><a class="header-anchor" href="#_1-introduction" aria-hidden="true">#</a> 1. Introduction</h2><p>Agile Modbus is a lightweight modbus protocol stack that meets the needs of users in any scenario.</p><figure><img src="'+r+'" alt="ModbusProtocol" tabindex="0" loading="lazy"><figcaption>ModbusProtocol</figcaption></figure>',4),h={href:"https://loogg.github.io/agile_modbus/",target:"_blank",rel:"noopener noreferrer"},b=e("li",null,[e("p",null,[s("The "),e("code",null,"examples"),s(" folder provides examples on PC")])],-1),y={href:"https://github.com/loogg/agile_modbus_mcu_demos",target:"_blank",rel:"noopener noreferrer"},f={href:"https://github.com/loogg/AT32F437_Boot",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/loogg/HPM6750_Boot",target:"_blank",rel:"noopener noreferrer"},B=t(`<h3 id="_1-1-features" tabindex="-1"><a class="header-anchor" href="#_1-1-features" aria-hidden="true">#</a> 1.1. Features</h3><ol><li>Supports rtu and tcp protocols, is developed using pure C, does not involve any hardware interface, and can be used directly on any form of hardware.</li><li>Since it is developed using pure C and does not involve hardware, it can run the tcp protocol on the serial port and the rtu protocol on the network.</li><li>Support custom protocols compliant with modbus format.</li><li>Supports multiple masters and multiple slaves at the same time.</li><li>It is easy to use. You only need to initialize the rtu or tcp handle and call the corresponding API to package and unpack.</li></ol><h3 id="_1-2-directory-structure" tabindex="-1"><a class="header-anchor" href="#_1-2-directory-structure" aria-hidden="true">#</a> 1.2. Directory structure</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>doc</td><td>documentation</td></tr><tr><td>examples</td><td>examples</td></tr><tr><td>figures</td><td>materials</td></tr><tr><td>inc</td><td>header file</td></tr><tr><td>src</td><td>source code</td></tr><tr><td>util</td><td>Provides simple and practical components</td></tr></tbody></table><h3 id="_1-3-license" tabindex="-1"><a class="header-anchor" href="#_1-3-license" aria-hidden="true">#</a> 1.3. License</h3><p>Agile Modbus complies with the <code>Apache-2.0</code> license, see the <code>LICENSE</code> file for details.</p><h2 id="_2-use-agile-modbus" tabindex="-1"><a class="header-anchor" href="#_2-use-agile-modbus" aria-hidden="true">#</a> 2. Use Agile Modbus</h2><p>Please view the help document <a href="./doc/doxygen/Agile_Modbus.chm">doc/doxygen/Agile_Modbus.chm</a></p><h3 id="_2-1-transplantation" tabindex="-1"><a class="header-anchor" href="#_2-1-transplantation" aria-hidden="true">#</a> 2.1. Transplantation</h3><ul><li><p>Users need to implement the <code>send data</code>, <code>wait for data reception to end</code> and <code>clear the receive buffer</code> functions of the hardware interface</p><p>Regarding <code>waiting for data reception to end</code>, the following ideas are provided:</p><ol><li><p>General method</p><p>Every 20 /50 ms (this time can be set according to the baud rate and hardware, here is just a reference value) reads data from the hardware interface and stores it in the buffer and updates the offset until it cannot be read or the buffer is full. , exit reading.</p><p>This applies to both bare metal and operating systems, which can accomplish blocking via <code>select</code> or <code>semaphore</code>.</p></li><li><p>Serial port <code>DMA + IDLE</code> interrupt mode</p><p>Configure the <code>DMA + IDLE</code> interrupt, enable the flag in the interrupt, and determine whether the flag is set in the application program.</p><p>However, this solution is prone to problems. If the data bytes are slightly staggered, it will not be a frame. The first option is recommended.</p></li></ol></li><li><p>Host:</p><ol><li><code>agile_modbus_rtu_init</code> / <code>agile_modbus_tcp_init</code> initializes <code>RTU/TCP</code> environment</li><li><code>agile_modbus_set_slave</code> sets the slave address</li><li><code>Clear the receive cache</code></li><li><code>agile_modbus_serialize_xxx</code> package request data</li><li><code>Send data</code></li><li><code>Waiting for data reception to end</code></li><li><code>agile_modbus_deserialize_xxx</code> Parse response data</li><li>Data processed by users</li></ol></li><li><p>Slave machine:</p><ol><li>Implement the <code>agile_modbus_slave_callback_t</code> type callback function</li><li><code>agile_modbus_rtu_init</code> / <code>agile_modbus_tcp_init</code> initializes <code>RTU/TCP</code> environment</li><li><code>agile_modbus_set_slave</code> sets the slave address</li><li><code>Waiting for data reception to end</code></li><li><code>agile_modbus_slave_handle</code> processes request data</li><li><code>Clear the receive buffer</code> (optional)</li><li><code>Send data</code></li></ol></li><li><p>Special function code</p><p>You need to call the <code>agile_modbus_set_compute_meta_length_after_function_cb</code> and <code>agile_modbus_set_compute_data_length_after_meta_cb</code> APIs to set the callbacks for special function codes to be processed in master-slave mode.</p><ul><li><p><code>agile_modbus_set_compute_meta_length_after_function_cb</code></p><p><code>msg_type == AGILE_MODBUS_MSG_INDICATION</code>: Returns the data element length of the host request message (uint8_t type). If it is not a special function code, 0 must be returned.</p><p><code>msg_type == MSG_CONFIRMATION</code>: Returns the data element length (uint8_t type) of the slave response message. If it is not a special function code, 1 must be returned.</p></li><li><p><code>agile_modbus_set_compute_data_length_after_meta_cb</code></p><p><code>msg_type == AGILE_MODBUS_MSG_INDICATION</code>: Returns the data length after the data element of the host request message. If it is not a special function code, 0 must be returned.</p><p><code>msg_type == MSG_CONFIRMATION</code>: Returns the data length after the data element of the slave response message. If it is not a special function code, it must return 0.</p></li></ul></li><li><p><code>agile_modbus_rtu_init</code> / <code>agile_modbus_tcp_init</code></p><p>When initializing the <code>RTU/TCP</code> environment, the user needs to pass in the <code>send buffer</code> and <code>receive buffer</code>. It is recommended that the size of both buffers is <code>AGILE_MODBUS_MAX_ADU_LENGTH</code> (260) bytes. <code>Special function code</code> is determined by the user according to the agreement.</p><p>But for small memory MCUs, these two buffers can also be set small, and all APIs will judge the buffer size:</p><p>Send buffer setting: If <code>expected request data length</code> or <code>expected response data length</code> is greater than <code>set send buffer size</code>, an exception is returned.</p><p>Receive buffer setting: If the <code>message length requested by the host</code> is greater than the <code>set receive buffer size</code>, an exception will be returned. This is reasonable. When a small memory MCU is used as a slave, certain function codes must be restricted.</p></li></ul><h3 id="_2-2-host" tabindex="-1"><a class="header-anchor" href="#_2-2-host" aria-hidden="true">#</a> 2.2. Host</h3><p>See <code>2.1. Transplantation</code>.</p><h3 id="_2-3-slave-machine" tabindex="-1"><a class="header-anchor" href="#_2-3-slave-machine" aria-hidden="true">#</a> 2.3. Slave machine</h3><h4 id="_2-3-1-interface-description" tabindex="-1"><a class="header-anchor" href="#_2-3-1-interface-description" aria-hidden="true">#</a> 2.3.1. Interface description</h4><ul><li><p>Introduction to <code>agile_modbus_slave_handle</code></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">agile_modbus_slave_handle</span><span style="color:#ABB2BF;">(</span><span style="color:#56B6C2;">agile_modbus_t</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">*</span><span style="color:#E06C75;font-style:italic;">ctx</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">int</span><span style="color:#E06C75;"> </span><span style="color:#E06C75;font-style:italic;">msg_length</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">uint8_t</span><span style="color:#E06C75;"> </span><span style="color:#E06C75;font-style:italic;">slave_strict</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">                              </span><span style="color:#56B6C2;">agile_modbus_slave_callback_t</span><span style="color:#E06C75;"> </span><span style="color:#E06C75;font-style:italic;">slave_cb</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">const</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">void</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">*</span><span style="color:#E06C75;font-style:italic;">slave_data</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">int</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">*</span><span style="color:#E06C75;font-style:italic;">frame_length</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>msg_length: The length of data received after <code>waiting for the end of data reception</code>.</p><p>slave_strict: slave address strictness check (0: Do not judge whether the address is consistent, it will be processed by user callback; 1: The address must be consistent, otherwise the callback will not be called and the response data will not be packaged).</p><p>slave_cb: <code>agile_modbus_slave_callback_t</code> type callback function, implemented and passed in by the user. If it is NULL, all function codes can respond and are successful, but the register data is still 0.</p><p>slave_data: slave callback function private data.</p><p>frame_length: Get the length of the parsed modbus data frame. The meaning of this parameter is:</p><ol><li>There is dirty data at the end: it can still be parsed successfully and tells the user the real modbus frame length, which the user can process.</li><li>Data sticky packet: The data consists of a complete frame of modbus data + a partial modbus data frame. After the user obtains the real modbus frame length, he can remove the processed modbus data frame and read the hardware interface data and the current one again. Part of the modbus data frame forms a new frame</li><li>This parameter is often used when modbus broadcast transmits big data (such as custom function code broadcast to upgrade firmware). Ordinary slave responses are one question and one answer, and only the complete data frame is processed. It is recommended to Execute <code>clear receive cache</code></li></ol></li><li><p>Introduction to <code>agile_modbus_slave_callback_t</code></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> * </span><span style="color:#C678DD;font-style:italic;">@brief</span><span style="color:#7F848E;font-style:italic;">   slave callback function</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> * </span><span style="color:#C678DD;font-style:italic;">@param</span><span style="color:#7F848E;font-style:italic;">   </span><span style="color:#E06C75;font-style:italic;">ctx</span><span style="color:#7F848E;font-style:italic;"> modbus handle</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> * </span><span style="color:#C678DD;font-style:italic;">@param</span><span style="color:#7F848E;font-style:italic;">   </span><span style="color:#E06C75;font-style:italic;">slave_info</span><span style="color:#7F848E;font-style:italic;"> slave information body</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> * </span><span style="color:#C678DD;font-style:italic;">@param</span><span style="color:#7F848E;font-style:italic;">   </span><span style="color:#E06C75;font-style:italic;">data</span><span style="color:#7F848E;font-style:italic;"> private data</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> * </span><span style="color:#C678DD;font-style:italic;">@return</span><span style="color:#7F848E;font-style:italic;">  =0: normal;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> *          &lt;0: Abnormal</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> *             (-AGILE_MODBUS_EXCEPTION_UNKNOW(-255): Unknown exception, the slave will not package the response data)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> *             (Other negative exception codes: package exception response data from the opportunity)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C678DD;">typedef</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">*</span><span style="color:#56B6C2;">agile_modbus_slave_callback_t</span><span style="color:#ABB2BF;">)(</span><span style="color:#56B6C2;">agile_modbus_t</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">ctx, </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> agile_modbus_slave_info </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">slave_info, </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">data);</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>agile_modbus_slave_info</code>:</p><p>sft: Contains slave address and function code attributes, which can be used in callbacks</p><p>rsp_length: response data length pointer, its value needs to be updated when processing <code>special function code</code> in the callback, otherwise <strong>not allowed to change</strong></p><p>address: register address (not used by all function codes)</p><p>nb: number (not used by all function codes)</p><p>buf: data field required by different function codes (not used by all function codes)</p><p>send_index: the current index of the send buffer (not used by all function codes)</p></li><li><p><code>agile_modbus_slave_info</code> used by different function codes</p><ul><li><p>AGILE_MODBUS_FC_READ_COILS、AGILE_MODBUS_FC_READ_DISCRETE_INPUTS</p><p>The <code>address</code>, <code>nb</code>, and <code>send_index</code> attributes need to be used, and the <code>agile_modbus_slave_io_set</code> API needs to be called to store the IO data in the data area starting from <code>ctx-&gt;send_buf + send_index</code>.</p></li><li><p>AGILE_MODBUS_FC_READ_HOLDING_REGISTERS、AGILE_MODBUS_FC_READ_INPUT_REGISTERS</p><p>The <code>address</code>, <code>nb</code>, and <code>send_index</code> attributes need to be used, and the <code>agile_modbus_slave_register_set</code> API needs to be called to store the register data in the data area starting from <code>ctx-&gt;send_buf + send_index</code>.</p></li><li><p>AGILE_MODBUS_FC_WRITE_SINGLE_COIL、AGILE_MODBUS_FC_WRITE_SINGLE_REGISTER</p><p>You need to use the <code>address</code> and <code>buf</code> attributes, force <code>buf</code> to the <code>int *</code> type, and get the value and store it in a register.</p></li><li><p>AGILE_MODBUS_FC_WRITE_MULTIPLE_COILS</p><p>The <code>address</code>, <code>nb</code>, <code>buf</code> attributes need to be used, and the <code>agile_modbus_slave_io_get</code> API needs to be called to obtain the IO data to be written.</p></li><li><p>AGILE_MODBUS_FC_WRITE_MULTIPLE_REGISTERS</p><p>The <code>address</code>, <code>nb</code>, and <code>buf</code> attributes need to be used, and the <code>agile_modbus_slave_register_get</code> API needs to be called to obtain the register data to be written.</p></li><li><p>AGILE_MODBUS_FC_MASK_WRITE_REGISTER</p><p>You need to use the <code>address</code> and <code>buf</code> attributes, pass <code>(buf[0] &lt;&lt; 8) + buf[1]</code> to get the <code>and</code> value, pass <code>(buf[2] &lt;&lt; 8) + buf[3 ]</code> Gets the <code>or</code> value. Get the register value <code>data</code>, perform the <code>data = (data &amp; and) | (or &amp; (~and))</code> operation to update the <code>data</code> value, and write it to the register.</p></li><li><p>AGILE_MODBUS_FC_WRITE_AND_READ_REGISTERS</p><p>You need to use the <code>address</code>, <code>buf</code>, <code>send_index</code> attributes, pass <code>(buf[0] &lt;&lt; 8) + buf[1]</code> to get the number of registers to be read, pass <code>(buf[2] &lt;&lt; 8) + buf[3]</code> Get the register address to be written, and use <code>(buf[4] &lt;&lt; 8) + buf[5]</code> to get the number of registers to be written. You need to call the <code>agile_modbus_slave_register_get</code> API to obtain the register data to be written, and call the <code>agile_modbus_slave_register_set</code> API to store the register data in the data area starting from <code>ctx-&gt;send_buf + send_index</code>.</p></li><li><p>Custom function code</p><p>You need to use the <code>send_index</code>, <code>nb</code>, and <code>buf</code> attributes, and the user processes the data in the callback.</p><p>send_index: current index of send buffer</p><p>nb: PUD - 1, which is the modbus data field length</p><p>buf: starting position of modbus data field</p><p><strong>Note</strong>: After the user fills data into the send buffer in the callback, the <code>rsp_length</code> value of <code>agile_modbus_slave_info</code> needs to be updated.</p></li></ul></li></ul><h4 id="_2-3-2-simple-slave-access-interface" tabindex="-1"><a class="header-anchor" href="#_2-3-2-simple-slave-access-interface" aria-hidden="true">#</a> 2.3.2. Simple slave access interface</h4><p>Agile Modbus provides an implementation of <code>agile_modbus_slave_callback_t</code>, allowing users to access it simply and conveniently.</p><p>See <a href="./examples/slave">examples/slave</a> for examples of usage.</p><p>How to use:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="color:#C678DD;">#include</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;agile_modbus.h&quot;</span></span>
<span class="line"><span style="color:#C678DD;">#include</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;agile_modbus_slave_util.h&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">agile_modbus_slave_util_t</span><span style="color:#ABB2BF;"> slave_util </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">  /* User implementation */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#61AFEF;">agile_modbus_slave_handle</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">ctx</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> read_len</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> agile_modbus_slave_util_callback</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">&amp;</span><span style="color:#E06C75;font-style:italic;">slave_util</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> </span><span style="color:#D19A66;">NULL</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>Introduction to <code>agile_modbus_slave_util_callback</code></p><ul><li><p>An implementation of <code>agile_modbus_slave_callback_t</code> provided by Agile Modbus, which requires <code>agile_modbus_slave_util_t</code> type variable pointer as private data.</p></li><li><p>The private data is NULL, all function codes can respond and are successful, but the register data is still 0.</p></li></ul></li><li><p>Introduction to <code>agile_modbus_slave_util_t</code></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="color:#C678DD;">typedef</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> agile_modbus_slave_util {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">agile_modbus_slave_util_map_t</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">tab_bits;</span><span style="color:#7F848E;font-style:italic;">                                            /**&lt; Coil register definition array */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> nb_bits;</span><span style="color:#7F848E;font-style:italic;">                                                                              /**&lt; Number of coil register definition arrays */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">agile_modbus_slave_util_map_t</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">tab_input_bits;</span><span style="color:#7F848E;font-style:italic;">                                      /**&lt; Discrete input register definition array */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> nb_input_bits;</span><span style="color:#7F848E;font-style:italic;">                                                                        /**&lt; Number of discrete input register definition arrays */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">agile_modbus_slave_util_map_t</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">tab_registers;</span><span style="color:#7F848E;font-style:italic;">                                       /**&lt; Holding register definition array */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> nb_registers;</span><span style="color:#7F848E;font-style:italic;">                                                                         /**&lt; Number of holding register definition arrays */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">agile_modbus_slave_util_map_t</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">tab_input_registers;</span><span style="color:#7F848E;font-style:italic;">                                 /**&lt; Input register definition array */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> nb_input_registers;</span><span style="color:#7F848E;font-style:italic;">                                                                   /**&lt; Number of input register definition arrays */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">addr_check)(</span><span style="color:#56B6C2;">agile_modbus_t</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">ctx, </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> agile_modbus_slave_info </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">slave_info);</span><span style="color:#7F848E;font-style:italic;">       /**&lt; Address check interface */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">special_function)(</span><span style="color:#56B6C2;">agile_modbus_t</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">ctx, </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> agile_modbus_slave_info </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">slave_info);</span><span style="color:#7F848E;font-style:italic;"> /**&lt; Special function code processing interface */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">done)(</span><span style="color:#56B6C2;">agile_modbus_t</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">ctx, </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> agile_modbus_slave_info </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">slave_info, </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> ret);</span><span style="color:#7F848E;font-style:italic;">    /**&lt; Processing end interface */</span></span>
<span class="line"><span style="color:#ABB2BF;">} </span><span style="color:#56B6C2;">agile_modbus_slave_util_t</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>Register related</p><p>Users need to implement the definitions of <code>bits</code>, <code>input_bits</code>, <code>registers</code> and <code>input_registers</code>. If a register is defined as NULL, the function code corresponding to the register can respond and is successful, but the register data is all 0.</p></li><li><p>Interface calling process</p><figure><img src="`+d+`" alt="SlaveCallback" tabindex="0" loading="lazy"><figcaption>SlaveCallback</figcaption></figure></li></ul></li><li><p>Introduction to <code>agile_modbus_slave_util_map</code></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="color:#C678DD;">typedef</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> agile_modbus_slave_util_map {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> start_addr;</span><span style="color:#7F848E;font-style:italic;">                                       /**&lt; starting address */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> end_addr;</span><span style="color:#7F848E;font-style:italic;">                                         /**&lt; end address */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">get)(</span><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">buf, </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> bufsz);</span><span style="color:#7F848E;font-style:italic;">                     /**&lt; Get register data interface */</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">set)(</span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> index, </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> len, </span><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">buf, </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> bufsz);</span><span style="color:#7F848E;font-style:italic;"> /**&lt; Set register data interface */</span></span>
<span class="line"><span style="color:#ABB2BF;">} </span><span style="color:#56B6C2;">agile_modbus_slave_util_map_t</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>Precautions</strong>:</p><ul><li><p>The number of registers determined by the start address and end address is limited. Changing the size of the <code>map_buf</code> array inside the function can make it larger.</p><ul><li><p>bit register &lt; 250</p></li><li><p>register register &lt; 125</p></li></ul></li><li><p>The interface function is NULL, and the function code corresponding to the register can respond and is successful.</p></li></ul></li><li><p><code>get</code> interface</p><p>Copy all data in the address field to <code>buf</code>.</p></li><li><p><code>set</code> interface</p><ul><li><p><code>index</code>: offset within the address field</p></li><li><p><code>len</code>: length</p></li></ul><p>Modify data based on <code>index</code> and <code>len</code>.</p></li></ul></li></ul><h3 id="_2-4-example" tabindex="-1"><a class="header-anchor" href="#_2-4-example" aria-hidden="true">#</a> 2.4. Example</h3>`,22),g=t('<li><p>Examples on PC are provided in the <a href="./examples">examples</a> folder, which can be compiled and run under <code>WSL</code> or <code>Linux</code>.</p><ul><li><p>Examples of RTU/TCP master and slave</p></li><li><p>Examples of special function codes</p><p>RTU point-to-point transmission of files: Demonstrates the use of special function codes</p><p>RTU broadcast transmission file: Demonstrates the use of <code>frame_length</code> in <code>agile_modbus_slave_handle</code></p></li></ul></li>',1),v={href:"https://github.com/loogg/agile_modbus_mcu_demos",target:"_blank",rel:"noopener noreferrer"},D={href:"https://github.com/loogg/AT32F437_Boot",target:"_blank",rel:"noopener noreferrer"},A={href:"https://github.com/loogg/HPM6750_Boot",target:"_blank",rel:"noopener noreferrer"},C=t('<h3 id="_2-5-doxygen-document-generation" tabindex="-1"><a class="header-anchor" href="#_2-5-doxygen-document-generation" aria-hidden="true">#</a> 2.5. Doxygen document generation</h3><ul><li>Use <code>Doxywizard</code> to open <a href="./doc/doxygen/Doxyfile">Doxyfile</a> and run it. The generated file will be under <a href="./doc/doxygen/output">doxygen/output</a>.</li><li><code>Graphviz</code> path needs to be changed.</li><li><code>HTML</code> is generated without using <code>chm</code> format. If it is enabled, you need to change the <code>hhc.exe</code> path.</li></ul><h2 id="_3-support" tabindex="-1"><a class="header-anchor" href="#_3-support" aria-hidden="true">#</a> 3. Support</h2><figure><img src="'+p+'" alt="zanshang" tabindex="0" loading="lazy"><figcaption>zanshang</figcaption></figure><p>If Agile Modbus solves your problem, you might as well scan the QR code above and invite me for a <strong>cup of coffee</strong> ~</p><h2 id="_4-contact-information-thanks" tabindex="-1"><a class="header-anchor" href="#_4-contact-information-thanks" aria-hidden="true">#</a> 4. Contact information &amp; thanks</h2>',6),F=e("li",null,"Maintenance: Ma Longwei",-1),E={href:"https://github.com/loogg/agile_modbus",target:"_blank",rel:"noopener noreferrer"},x=e("li",null,[s("Email: "),e("a",{href:"mailto:2544047213@qq.com"},"2544047213@qq.com")],-1);function I(k,T){const a=l("ExternalLinkIcon");return i(),c("div",null,[_,e("ul",null,[e("li",null,[e("p",null,[s("Online documentation: "),e("a",h,[s("API Manual"),n(a)])])]),b,e("li",null,[e("p",null,[s("See examples on MCU "),e("a",y,[s("mcu_demos"),n(a)])])]),e("li",null,[e("p",null,[s("Bootloader based on RT-Thread on AT32F437 that supports Modbus firmware upgrade: "),e("a",f,[s("AT32F437_Boot"),n(a)])])]),e("li",null,[e("p",null,[s("Bootloader based on RT-Thread on HPM6750 that supports Modbus firmware upgrade: "),e("a",m,[s("HPM6750_Boot"),n(a)])])])]),B,e("ul",null,[g,e("li",null,[e("p",null,[e("a",v,[s("mcu_demos"),n(a)]),s(" provides examples on MCU.")])]),e("li",null,[e("p",null,[e("a",D,[s("AT32F437_Boot"),n(a)]),s(" A Bootloader based on RT-Thread implemented on AT32F437 that supports Modbus firmware upgrade.")])]),e("li",null,[e("p",null,[e("a",A,[s("HPM6750_Boot"),n(a)]),s(" A Bootloader based on RT-Thread implemented on HPM6750 that supports Modbus firmware upgrade.")])])]),C,e("ul",null,[F,e("li",null,[s("Home page: "),e("a",E,[s("https://github.com/loogg/agile_modbus"),n(a)])]),x])])}const S=o(u,[["render",I],["__file","index.html.vue"]]);export{S as default};
