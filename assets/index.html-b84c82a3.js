import{_ as e,o as a,c as o,f as d}from"./app-9456f732.js";const t="/assets/VirtualCom-5992a2ee.jpg",s="/assets/ModbusSlaveSetup-25dcff96.jpg",l="/assets/ModbusSlaveRTUConnection-c672641a.jpg",i="/assets/RTUMaster-555de4da.jpg",n="/assets/ModbusSlaveTCPConnection-da6275e1.jpg",c="/assets/TCPMaster-b202d33c.jpg",r="/assets/ModbusPollSetup-47d65bc7.jpg",p="/assets/ModbusPollRTUConnection-22a3bb62.jpg",u="/assets/ModbusPollTCPConnection-104bb4db.jpg",g="/assets/ModbusSlaveShow-2d066278.jpg",b="/assets/ModbusSlaveTimeoutShow-2c1e0304.jpg",h="/assets/ModbusProtocol-7900ee6e.jpg",_="/assets/VirtualComGroup-c6b03ba8.jpg",f="/assets/rtu_p2p-5ae6f175.gif",y="/assets/rtu_broadcast-e0c0db9c.gif",m={},x=d('<h1 id="示例说明" tabindex="-1"><a class="header-anchor" href="#示例说明" aria-hidden="true">#</a> 示例说明</h1><h2 id="_1、介绍" tabindex="-1"><a class="header-anchor" href="#_1、介绍" aria-hidden="true">#</a> 1、介绍</h2><p>该示例提供 RTU / TCP 主机和从机的功能演示。</p><p><code>WSL</code> 或 <code>Linux</code> 下使用 <code>gcc</code> 可直接 <code>make all</code> 编译出所有示例，在电脑上运行测试程序。</p><p>目录结构：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>common</td><td>公用源码</td></tr><tr><td>figures</td><td>素材</td></tr><tr><td>rtu_master</td><td>RTU 主机示例</td></tr><tr><td>tcp_master</td><td>TCP 主机示例</td></tr><tr><td>slave</td><td>RTU + TCP 从机示例</td></tr><tr><td>rtu_p2p</td><td>RTU 点对点传输文件</td></tr><tr><td>rtu_broadcast</td><td>RTU 广播传输文件 (粘包处理示例)</td></tr></tbody></table><h2 id="_2、使用" tabindex="-1"><a class="header-anchor" href="#_2、使用" aria-hidden="true">#</a> 2、使用</h2><p>需要准备的工具如下：</p><ul><li>虚拟串口软件</li><li>Modbus Poll</li><li>Modbus Slave</li></ul><p>命令行敲击 <code>make clean</code> 、 <code>make all</code> 。</p><h3 id="_2-1、主机" tabindex="-1"><a class="header-anchor" href="#_2-1、主机" aria-hidden="true">#</a> 2.1、主机</h3><ul><li><p>RTU (rtu_master)</p><ul><li><p>使用虚拟串口软件虚拟出一对串口</p><figure><img src="'+t+'" alt="VirtualCom" tabindex="0" loading="lazy"><figcaption>VirtualCom</figcaption></figure></li><li><p>打开 <code>Modbus Slave</code> ，按下图设置</p><figure><img src="'+s+'" alt="ModbusSlaveSetup" tabindex="0" loading="lazy"><figcaption>ModbusSlaveSetup</figcaption></figure></li><li><p><code>Modbus Slave</code> 连接，按下图设置</p><figure><img src="'+l+'" alt="ModbusSlaveRTUConnection" tabindex="0" loading="lazy"><figcaption>ModbusSlaveRTUConnection</figcaption></figure></li><li><p>进入 <code>rtu_master</code> 目录，<code>./RtuMaster /dev/ttySX</code> 运行 <code>RTU</code> 主机示例，<code>ttySX</code> 为一对虚拟串口中的另一个</p><figure><img src="'+i+'" alt="RTUMaster" tabindex="0" loading="lazy"><figcaption>RTUMaster</figcaption></figure></li></ul></li><li><p>TCP (tcp_master)</p><ul><li><p>打开 <code>Modbus Slave</code>，<code>SetUp</code> 设置同 <code>RTU</code> 一致</p></li><li><p><code>Modbus Slave</code> 连接，按下图设置</p><figure><img src="'+n+'" alt="ModbusSlaveTCPConnection" tabindex="0" loading="lazy"><figcaption>ModbusSlaveTCPConnection</figcaption></figure></li><li><p>进入 <code>tcp_master</code> 目录，<code>./TcpMaster 127.0.0.1 502</code> 运行 <code>TCP</code> 主机示例</p><figure><img src="'+c+'" alt="TCPMaster" tabindex="0" loading="lazy"><figcaption>TCPMaster</figcaption></figure></li></ul></li></ul><h3 id="_2-2、从机" tabindex="-1"><a class="header-anchor" href="#_2-2、从机" aria-hidden="true">#</a> 2.2、从机</h3><ul><li><p>该示例 (slave) 同时提供 <code>RTU</code> 和 <code>TCP</code> 从机功能演示，控制的是同一片内存。<code>TCP</code> 最大可接入 5 个客户端，每个客户端无数据超时为 10s, 10s 后自动断开。</p></li><li><p>示例支持所有功能码(除了功能码 0x07)。</p></li><li><p>对 <code>bit</code>、<code>input_bit</code>、<code>register</code>、<code>input_register</code> 寄存器每个文件单独定义。</p></li><li><p>使用 <code>agile_modbus_slave_util_callback</code> 。</p></li><li><p>寄存器地址域：</p><table><thead><tr><th>寄存器</th><th>地址范围</th></tr></thead><tbody><tr><td>线圈寄存器</td><td>0x041A ~ 0x0423 (1050 ~ 1059)</td></tr><tr><td>离散量输入寄存器</td><td>0x041A ~ 0x0423 (1050 ~ 1059)</td></tr><tr><td>保持寄存器</td><td>0xFFF6 ~ 0xFFFF (65526 ~ 65535)</td></tr><tr><td>输入寄存器</td><td>0xFFF6 ~ 0xFFFF (65526 ~ 65535)</td></tr></tbody></table></li></ul><p><strong>注意</strong>: 读写其他地址寄存器都能成功，但值都为 0。</p><p>使用：</p><ul><li><p>使用虚拟串口软件虚拟出一对串口</p><figure><img src="'+t+'" alt="VirtualCom" tabindex="0" loading="lazy"><figcaption>VirtualCom</figcaption></figure></li><li><p>进入 <code>slave</code> 目录，<code>./ModbusSlave /dev/ttyS2 1025</code> 运行示例</p><p>/dev/ttySX: 虚拟串口中的一个</p><p>1025：监听端口号，如果不是 <code>root</code> 权限，端口号必须大于 <code>1024</code></p></li><li><p>打开 <code>Modbus Poll</code> 按下图设置和连接 RTU</p><figure><img src="'+r+'" alt="ModbusPollSetup" tabindex="0" loading="lazy"><figcaption>ModbusPollSetup</figcaption></figure><figure><img src="'+p+'" alt="ModbusPollRTUConnection" tabindex="0" loading="lazy"><figcaption>ModbusPollRTUConnection</figcaption></figure></li><li><p>打开 5 个 <code>Modbus Poll</code> ，设置同 RTU，连接如下图</p><figure><img src="'+u+'" alt="ModbusPollTCPConnection" tabindex="0" loading="lazy"><figcaption>ModbusPollTCPConnection</figcaption></figure></li><li><p>效果演示</p><figure><img src="'+g+'" alt="ModbusSlaveShow" tabindex="0" loading="lazy"><figcaption>ModbusSlaveShow</figcaption></figure></li><li><p>超时断开演示</p><p>将 <code>Modbus Poll</code> 的 poll 界面关闭，看控制台打印可以看到 close 报文。</p><figure><img src="'+b+'" alt="ModbusSlaveTimeoutShow" tabindex="0" loading="lazy"><figcaption>ModbusSlaveTimeoutShow</figcaption></figure></li></ul><h3 id="_2-3、rtu-传输文件" tabindex="-1"><a class="header-anchor" href="#_2-3、rtu-传输文件" aria-hidden="true">#</a> 2.3、RTU 传输文件</h3><figure><img src="'+h+'" alt="ModbusProtocol" tabindex="0" loading="lazy"><figcaption>ModbusProtocol</figcaption></figure><p>使用 <code>0x50</code> 作为传输文件的特殊功能码。</p><p>分包传输文件数据，每包数据最大 1024 字节。</p><p><code>Data</code> 字段协议定义：</p><ul><li><p>主机请求</p><table><thead><tr><th>命令</th><th>字节数</th><th>数据</th></tr></thead><tbody><tr><td>2 Bytes</td><td>2 Bytes</td><td>N Bytes</td></tr></tbody></table><p>命令:</p><table><thead><tr><th>命令</th><th>说明</th><th>数据</th></tr></thead><tbody><tr><td>0x0001</td><td>开始发送</td><td>文件大小(4 Bytes) + 文件名称(字符串)</td></tr><tr><td>0x0002</td><td>传输数据</td><td>标志(1 Byte) + 文件数据</td></tr></tbody></table><p>标志:</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>0x00</td><td>最后一包数据</td></tr><tr><td>0x01</td><td>不是最后一包数据</td></tr></tbody></table></li><li><p>从机响应</p><table><thead><tr><th>命令</th><th>状态</th></tr></thead><tbody><tr><td>2 Bytes</td><td>1 Byte</td></tr></tbody></table><p>状态:</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>0x00</td><td>失败</td></tr><tr><td>0x01</td><td>成功</td></tr></tbody></table></li><li><p>使用虚拟串口软件虚拟出 3 个串口，组成串口群组</p><p>这里我使用的时 MX 虚拟串口</p><figure><img src="'+_+'" alt="VirtualComGroup" tabindex="0" loading="lazy"><figcaption>VirtualComGroup</figcaption></figure></li></ul><h4 id="_2-3-1、点对点传输" tabindex="-1"><a class="header-anchor" href="#_2-3-1、点对点传输" aria-hidden="true">#</a> 2.3.1、点对点传输</h4><ul><li><p>进入 <code>rtu_p2p</code> 目录，打开 <code>Linux Shell</code>，演示效果如下</p><p><strong>注意</strong>:</p><ul><li><p>传输的文件必须是一般文件，像可执行文件、目录等不支持</p></li><li><p>文件路径必须是 <code>Linux</code> 环境下的路径</p></li><li><p>从机接收到数据后修改文件名称 (从机地址_原文件名) 写入在当前目录。</p></li></ul><figure><img src="'+f+`" alt="rtu_p2p" tabindex="0" loading="lazy"><figcaption>rtu_p2p</figcaption></figure></li></ul><h4 id="_2-3-2、广播传输" tabindex="-1"><a class="header-anchor" href="#_2-3-2、广播传输" aria-hidden="true">#</a> 2.3.2、广播传输</h4><p>该例子主要演示 <code>agile_modbus_slave_handle</code> 中 <code>frame_length</code> 的用处。</p><p><code>broadcast_master</code> 中，使用广播地址 0，周期 5ms 发送数据包。同时每包数据后都发送 100 字节的脏数据。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> send_len </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">agile_modbus_serialize_raw_request</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">ctx</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> raw_req</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> raw_req_len</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#61AFEF;">serial_send</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">_fd</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> ctx</span><span style="color:#C678DD;">-&gt;</span><span style="color:#E06C75;font-style:italic;">send_buf</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> send_len</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">//脏数据</span></span>
<span class="line"><span style="color:#61AFEF;">serial_send</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">_fd</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> _dirty_buf</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">sizeof</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">_dirty_buf</span><span style="color:#ABB2BF;">));</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在如此快速的数据流下，<code>broadcast_slave</code> 必须使用 <code>agile_modbus_slave_handle</code> 中 <code>frame_length</code> 参数来对粘包进行处理。</p><ul><li><p>进入 <code>rtu_broadcast</code> 目录，打开 <code>Linux Shell</code>，演示效果如下</p><p><strong>注意</strong>:</p><ul><li><p>传输的文件必须是一般文件，像可执行文件、目录等不支持</p></li><li><p>文件路径必须是 <code>Linux</code> 环境下的路径</p></li><li><p>从机接收到数据后修改文件名称 (从机地址_原文件名) 写入在当前目录。</p></li></ul><figure><img src="`+y+'" alt="rtu_broadcast" tabindex="0" loading="lazy"><figcaption>rtu_broadcast</figcaption></figure></li></ul>',31),B=[x];function v(C,M){return a(),o("div",null,B)}const T=e(m,[["render",v],["__file","index.html.vue"]]);export{T as default};
